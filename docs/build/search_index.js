var documenterSearchIndex = {"docs":
[{"location":"api/","page":"-","title":"-","text":"Modules = [FLOWVPM]\nOrder = [:constant, :type, :function]\n# Pages = [\"FLOWVPM.jl\"]","category":"page"},{"location":"api/#FLOWVPM.DynamicSFS","page":"-","title":"FLOWVPM.DynamicSFS","text":"Subfilter-scale scheme with an associated dynamic procedure for calculating\n\nthe model coefficient.\n\n\n\n\n\n","category":"type"},{"location":"api/#FLOWVPM.FMM","page":"-","title":"FLOWVPM.FMM","text":"`FMM(; p::Int=4, ncrit::Int=50, theta::Real=0.4, phi::Real=0.3)`\n\nParameters for FMM solver.\n\nArguments\n\np       : Order of multipole expansion (number of terms).\nncrit   : Maximum number of particles per leaf.\ntheta   : Neighborhood criterion. This criterion defines the distance               where the far field starts. The criterion is that if θ*r < R1+R2               the interaction between two cells is resolved through P2P, where               r is the distance between cell centers, and R1 and R2 are each               cell radius. This means that at θ=1, P2P is done only on cells               that have overlap; at θ=0.5, P2P is done on cells that their               distance is less than double R1+R2; at θ=0.25, P2P is done on               cells that their distance is less than four times R1+R2; at               θ=0, P2P is done on cells all cells.\nphi     : Regularizing neighborhood criterion. This criterion avoid               approximating interactions with the singular-FMM between               regularized particles that are sufficiently close to each other               across cell boundaries. Used together with the θ-criterion, P2P               is performed between two cells if φ < σ/dx, where σ is the               average smoothing radius in between all particles in both cells,               and dx is the distance between cell boundaries               ( dx = r-(R1+R2) ). This means that at φ = 1, P2P is done on               cells with boundaries closer than the average smoothing radius;               at φ = 0.5, P2P is done on cells closer than two times the               smoothing radius; at φ = 0.25, P2P is done on cells closer than               four times the smoothing radius.\n\n\n\n\n\n","category":"type"},{"location":"api/#FLOWVPM.Kernel","page":"-","title":"FLOWVPM.Kernel","text":"Kernel(zeta, g, dgdr, g_dgdr, EXAFMM_P2P, EXAFMM_L2P)\n\nArguments\n\nzeta::Function        : Basis function zeta(r).\ng::Function           : Regularizing function g(r).\ndgdr::Function        : Derivative of g(r).\ng_dgdr::Function      : Efficient evaluation of g and dgdr.\n\n\n\n\n\n","category":"type"},{"location":"api/#FLOWVPM.Relaxation","page":"-","title":"FLOWVPM.Relaxation","text":"`Relaxation(relax, nsteps_relax, rlxf)`\n\nDefines a relaxation method implemented in the function relax(rlxf::Real, p) where p is particle, rlxf is the relaxation factor between 0 and 1, with 0 == no relaxation, and 1 == full relaxation. The simulation is relaxed every nsteps_relax steps.\n\n\n\n\n\n","category":"type"},{"location":"api/#FLOWVPM.SubFilterScale-Tuple{Any, FLOWVPM.BeforeUJ}","page":"-","title":"FLOWVPM.SubFilterScale","text":"Implementation of calculations associated with subfilter-scale turbulence\n\nmodel.\n\nThe model is expected to be called in two stages surrounding the calculation of the induced velocity, as:\n\nthis_sfs_model(pfield::ParticleField, beforeUJ::BeforeUJ)\n\npfield.UJ(pfield; sfs=true, reset=true, reset_sfs=true)\n\nthis_sfs_model(pfield::ParticleField, afterUJ::AfterUJ)\n\n(See implementation of ConstantSFS as an example.)\n\nNOTE1: The UJ_fmm requires <:SubFilterScale objects to contain a sfs.model field, which is a function that computes the SFS contribution to the stretching term.\n\nNOTE2: Any control strategy is implemented as a function that returns true whenever the SFS model needs to be clipped. Subsequently, the model coefficient of the targeted particle will be turned to zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.ViscousScheme","page":"-","title":"FLOWVPM.ViscousScheme","text":"`ViscousScheme{R}`\n\nType declaring viscous scheme.\n\nImplementations must have the following properties:     * nu::R                   : Kinematic viscosity.\n\n\n\n\n\n","category":"type"},{"location":"api/#FLOWVPM.E_nostaticparticles-Tuple{Any, Vararg{Any}}","page":"-","title":"FLOWVPM.E_nostaticparticles","text":"SFS model wrapper that hides the static particles from the model in order\n\nto avoid potential numerical instabilities encountered at solid surfaces.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.Estr_direct-NTuple{5, Any}","page":"-","title":"FLOWVPM.Estr_direct","text":"Model of vortex-stretching SFS contributions evaluated with direct\n\nparticle-to-particle interactions. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.Estr_fmm-Tuple{ParticleField}","page":"-","title":"FLOWVPM.Estr_fmm","text":"Model of vortex-stretching SFS contributions evaluated with fast multipole\n\nmethod. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.UJ_direct-Tuple{ParticleField, ParticleField}","page":"-","title":"FLOWVPM.UJ_direct","text":"UJ_direct(source, target)\n\nCalculates the velocity and Jacobian that the field source exerts on every particle of  field target, saving U and J on the particles.\n\nNOTE: This method accumulates the calculation on the properties U and J of every particle without previously emptying those properties.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.UJ_direct-Tuple{ParticleField}","page":"-","title":"FLOWVPM.UJ_direct","text":"UJ_direct(pfield)\n\nCalculates the velocity and Jacobian that the field exerts on itself by direct particle-to-particle interaction, saving U and J on the particles.\n\nNOTE: This method accumulates the calculation on the properties U and J of every particle without previously emptying those properties.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.UJ_fmm-Union{Tuple{ParticleField{<:Any, <:Any, <:Any, <:Any, <:Any, <:Any, <:Any, <:Any, <:Any, useGPU}}, Tuple{useGPU}} where useGPU","page":"-","title":"FLOWVPM.UJ_fmm","text":"UJ_fmm(pfield)\n\nCalculates the velocity and Jacobian that the field exerts on itself through a fast-multipole approximation, saving U and J on the particles.\n\nNOTE: This method accumulates the calculation on the properties U and J of every particle without previously emptying those properties.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM._euler-Union{Tuple{R2}, Tuple{V}, Tuple{R}, Tuple{ParticleField{R, <:ReformulatedVPM{R2}, V}, Real}} where {R, V, R2}","page":"-","title":"FLOWVPM._euler","text":"Steps the field forward in time by dt in a first-order Euler integration scheme using the VPM reformulation. See notebook 20210104.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM._euler-Union{Tuple{V}, Tuple{R}, Tuple{ParticleField{R, <:ClassicVPM, V}, Any}} where {R, V}","page":"-","title":"FLOWVPM._euler","text":"Steps the field forward in time by dt in a first-order Euler integration scheme.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM._get_settings-Tuple{ParticleField}","page":"-","title":"FLOWVPM._get_settings","text":"Return a hash table with the solver settings of the particle field.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.add_particle-Tuple{ParticleField, Any, Any, Any}","page":"-","title":"FLOWVPM.add_particle","text":"add_particle(pfield::ParticleField, X, Gamma, sigma; vol=0)\n\nAdd a particle to the field.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.add_particle-Tuple{ParticleField, Any}","page":"-","title":"FLOWVPM.add_particle","text":"add_particle(pfield::ParticleField, P)\n\nAdd a copy of Particle P to the field.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.clipping_backscatter-Tuple{Any, Any}","page":"-","title":"FLOWVPM.clipping_backscatter","text":"Backscatter control strategy of SFS enstrophy production by clipping of the\n\nSFS model. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.control_directional-Tuple{Any, Any}","page":"-","title":"FLOWVPM.control_directional","text":"Directional control strategy of SFS enstrophy production forcing the model\n\nto affect only the vortex strength magnitude and not the vortex orientation. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.control_magnitude-Tuple{Any, Any}","page":"-","title":"FLOWVPM.control_magnitude","text":"Magnitude control strategy of SFS enstrophy production limiting the\n\nmagnitude of the forward scattering (diffussion) of the model. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.create_path-Tuple{String, Bool}","page":"-","title":"FLOWVPM.create_path","text":"create_path(save_path::String, prompt::Bool)\n\nCreate folder save_path. prompt prompts the user if true.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.dynamicprocedure_pseudo3level_beforeUJ-Union{Tuple{R}, Tuple{Any, FLOWVPM.SubFilterScale{R}, Vararg{Real, 4}}} where R","page":"-","title":"FLOWVPM.dynamicprocedure_pseudo3level_beforeUJ","text":"Dynamic procedure for SFS model coefficient based on enstrophy and\n\nderivative balance between resolved and unresolved domain, numerically implemented through pseudo-three filtering levels. See 20210901 notebook for derivation.\n\nNOTES\n\nrlxf = Δ𝑡/𝑇 ≤ 1 is the relaxation factor of the Lagrangian average, where Δ𝑡\n\nis the time step of the simulation, and 𝑇 is the time length of the ensemble average.\n\nThe scaling constant becomes 1 for alpha_tau = 1 (but notice that the\n\nderivative approximation becomes zero at that point). Hence, the pseudo-three-level procedure converges to the two-level procedure for alpha_tau rightarrow 1**.\n\nThe scaling constant tends to zero when alpha_tau rightarrow 23. Hence,\n\nit can be used to arbitrarely attenuate the SFS contributions with alpha_tau rightarrow 23, or let it trully be a self-regulated dynamic procedure with alpha_tau rightarrow 1.\n\nalpha_tau\nshould not be made smaller than 23 as the constant becomes\n\nnegative beyond that point. This strains the assumption that sigma_tau is small enough to approximate the singular velocity field as mathbfu approx mathbftildeu, which now is only true if sigma is small enough.\n\n𝛼𝜏=0.999 ⇒ 3𝛼𝜏−2=0.997 𝛼𝜏=0.990 ⇒ 3𝛼𝜏−2=0.970 𝛼𝜏=0.900 ⇒ 3𝛼𝜏−2=0.700 𝛼𝜏=0.833 ⇒ 3𝛼𝜏−2=0.499 𝛼𝜏=0.750 ⇒ 3𝛼𝜏−2=0.250 𝛼𝜏=0.700 ⇒ 3𝛼𝜏−2=0.100 𝛼𝜏=0.675 ⇒ 3𝛼𝜏−2=0.025 𝛼𝜏=0.670 ⇒ 3𝛼𝜏−2=0.010 𝛼𝜏=0.667 ⇒ 3𝛼𝜏−2=0.001 𝛼𝜏=0.6667⇒ 3𝛼𝜏−2=0.0001\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.dynamicprocedure_sensorfunction-Union{Tuple{R}, Tuple{Any, FLOWVPM.SubFilterScale{R}, Vararg{Real, 4}}} where R","page":"-","title":"FLOWVPM.dynamicprocedure_sensorfunction","text":"Dynamic procedure for SFS model coefficient based on sensor function of\n\nenstrophy between resolved and unresolved domain, numerically implemented through a test filter. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.euler-Tuple{ParticleField, Any}","page":"-","title":"FLOWVPM.euler","text":"_euler(pfield, dt; relax=false)\n\nConvects the ::ParticleField by timestep dt using a forward Euler step.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.get_X-Tuple{ParticleField, Int64}","page":"-","title":"FLOWVPM.get_X","text":"Get functions for particles in ParticleField\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.get_np-Tuple{ParticleField}","page":"-","title":"FLOWVPM.get_np","text":"`get_np(pfield::ParticleField)`\n\nReturns current number of particles in the field.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.get_particle-Tuple{ParticleField, Int64}","page":"-","title":"FLOWVPM.get_particle","text":"`get_particle(pfield::ParticleField, i)`\n\nReturns the i-th particle in the field.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.get_particleiterator-Tuple","page":"-","title":"FLOWVPM.get_particleiterator","text":"`get_particleiterator(pfield::ParticleField; start_i=1, end_i=np)`\n\nReturn an iterator over particles that can be used as follows\n\njulia> # Initiate particle field\n       pfield = FLOWVPM.ParticleField(10);\n\njulia> # Add particles\n       for i in 1:4\n           FLOWVPM.add_particle(pfield, (i*10^0, i*10^1, i*10^2), zeros(3), 1.0)\n       end\n\njulia> # Iterate over particles\n       for P in FLOWVPM.get_particleiterator(pfield)\n           println(P.var[1:3])\n       end\n[1.0, 10.0, 100.0]\n[2.0, 20.0, 200.0]\n[3.0, 30.0, 300.0]\n[4.0, 40.0, 400.0]\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.isLES-Tuple{ParticleField}","page":"-","title":"FLOWVPM.isLES","text":"`isLES(pfield::ParticleField)`\n\nReturns true if the particle field solver implements a subfilter-scale model\n\nof turbulence for large eddy simulation (LES).\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.isSFSenabled-Tuple{FLOWVPM.SubFilterScale}","page":"-","title":"FLOWVPM.isSFSenabled","text":"Returns true if SFS scheme implements an SFS model\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.iscorespreading-Tuple{FLOWVPM.ViscousScheme}","page":"-","title":"FLOWVPM.iscorespreading","text":"iscorespreading(scheme::ViscousScheme)\n\nReturns true if viscous scheme is core spreading.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.isinviscid-Tuple{FLOWVPM.ViscousScheme}","page":"-","title":"FLOWVPM.isinviscid","text":"`isinviscid(scheme::ViscousScheme)`\n\nReturns true if viscous scheme is inviscid.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.isinviscid-Tuple{ParticleField}","page":"-","title":"FLOWVPM.isinviscid","text":"`isinviscid(pfield::ParticleField)`\n\nReturns true if particle field is inviscid.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.iterate-Tuple","page":"-","title":"FLOWVPM.iterate","text":"Alias for get_particleiterator\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.iterator-Tuple","page":"-","title":"FLOWVPM.iterator","text":"Alias for get_particleiterator\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.monitor_Cd-Tuple{Any, Any, Any}","page":"-","title":"FLOWVPM.monitor_Cd","text":"Runtime function that calculates the statistical properties of the SFS model coefficient across the particle field. Particles whose coefficients have been clipped are ignored.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.monitor_enstrophy_Gamma2-Tuple{Any, Any, Any}","page":"-","title":"FLOWVPM.monitor_enstrophy_Gamma2","text":"Runtime function that calculates the enstrophy of the particle field, or global enstrophy of the flow. This is calculated by integrating the local enstrophy defined as ξ = ω⋅ω / 2\n\nEnstrophy is approximated as 0.5*Σ( ζσ(0) Γ𝑝⋅Γ𝑝 ). This is inaccurate, but is a quick, dirty, and cheap way of getting an idea of how the enstrophy of the system may be evolving (see notebook 20210702).\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.monitor_enstrophy_Gammaomega-Tuple{Any, Any, Any}","page":"-","title":"FLOWVPM.monitor_enstrophy_Gammaomega","text":"Runtime function that calculates the enstrophy of the particle field, or global enstrophy of the flow. This is calculated by integrating the local enstrophy defined as ξ = ω⋅ω / 2\n\nEnstrophy is approximated as 0.5*Σ( Γ𝑝⋅ω(x𝑝) ). This is consistent with Winckelamns' 1995 CTR report (\"Some Progress in LES using the 3-D VPM\"). See notebook 20210702.\n\nNOTE: This function assumes that the vorticity field has already been precalculated, which is true if this function is called after the relaxation step. DON'T USE THIS MONITOR UNLESS YOU KNOW THAT THIS CONDITION IS MET.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.nextstep-Tuple{ParticleField, Real}","page":"-","title":"FLOWVPM.nextstep","text":"nextstep(pfield::ParticleField, dt; relax=false)\n\nSteps the particle field in time by a step dt.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.rbf_conjugategradient-Tuple{Any, FLOWVPM.CoreSpreading}","page":"-","title":"FLOWVPM.rbf_conjugategradient","text":"Radial basis function interpolation of Gamma using the conjugate gradient method. This method only works on a particle field with uniform smoothing radius sigma.\n\nSee 20180818 notebook and https://en.wikipedia.org/wiki/Conjugategradientmethod#Theresultingalgorithm\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.read!-Union{Tuple{V}, Tuple{F}, Tuple{R}, Tuple{ParticleField{R, F, V, <:Any, <:Any}, String}} where {R<:Real, F, V}","page":"-","title":"FLOWVPM.read!","text":"read(h5_fname; path=\"\")\n\nReads an HDF5 file containing a particle field created with save(pfield).\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.relax_correctedpedrizzetti-Tuple{Real, Any}","page":"-","title":"FLOWVPM.relax_correctedpedrizzetti","text":"`relax_correctedPedrizzetti(rlxf::Real, p)`\n\nRelaxation scheme where the vortex strength is aligned with the local vorticity. This version fixes the error in Pedrizzetti's relaxation that made the strength to continually decrease over time. See notebook 20200921 for derivation.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.relax_pedrizzetti-Tuple{Real, Any}","page":"-","title":"FLOWVPM.relax_pedrizzetti","text":"`relax_Pedrizzetti(rlxf::Real, p)`\n\nRelaxation scheme where the vortex strength is aligned with the local vorticity.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.remove_particle-Tuple{ParticleField, Int64}","page":"-","title":"FLOWVPM.remove_particle","text":"remove_particle(pfield::ParticleField, i)\n\nRemove the i-th particle in the field. This is done by moving the last particle that entered the field into the memory slot of the target particle. To remove particles sequentally, you will need to go from the last particle back to the first one (see documentation of get_particleiterator for an example).\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.run_vpm!-Tuple{ParticleField, Real, Int64}","page":"-","title":"FLOWVPM.run_vpm!","text":"run_vpm!(pfield, dt, nsteps; runtime_function=nothing, save_path=nothing, run_name=\"pfield\", nsteps_save=1, verbose=true, prompt=true)\n\nSolves nsteps of the particle field with a time step of dt.\n\nOptional Arguments\n\nruntime_function::Function   : Give it a function of the form                           myfun(pfield, t, dt). On each time step it                           will call this function. Use this for adding                           particles, deleting particles, etc.\nstatic_particles_function::Function   : Give it a function of the form                           myfun(pfield, t, dt) to add static particles                           representing solid boundaries to the solver. This                           function is called at every time step right before                           solving the governing equations, and any new                           particles added by this function are immediately                           removed.\nsave_path::String   : Give it a string for saving VTKs of the particle                           field. Creates the given path.\nrun_name::String    : Name of output files.\nnsteps_save::Int64  : Saves vtks every this many time steps.\nprompt::Bool        : If save_path already exist, it will prompt the                           user before overwritting the folder if true; it will                           directly overwrite it if false.\nverbose::Bool       : Prints progress of the run to the terminal.\nverbose_nsteps::Bool: Number of time steps between verbose.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.rungekutta3-Union{Tuple{R3}, Tuple{R2}, Tuple{V}, Tuple{R}, Tuple{ParticleField{R, <:ReformulatedVPM{R2}, V}, R3}} where {R, V, R2, R3}","page":"-","title":"FLOWVPM.rungekutta3","text":"Steps the field forward in time by dt in a third-order low-storage Runge-Kutta integration scheme using the VPM reformulation. See Notebook entry 20180105 (RK integration) and notebook 20210104 (reformulation).\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.rungekutta3-Union{Tuple{R3}, Tuple{V}, Tuple{R}, Tuple{ParticleField{R, <:ClassicVPM, V}, R3}} where {R, V, R3}","page":"-","title":"FLOWVPM.rungekutta3","text":"Steps the field forward in time by dt in a third-order low-storage Runge-Kutta integration scheme. See Notebook entry 20180105.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.save-Union{Tuple{TF}, Tuple{ParticleField{TF, <:Any, <:Any, <:Any, <:Any}, String}} where TF","page":"-","title":"FLOWVPM.save","text":"save(pfield, file_name; path=\"\")\n\nSaves the particle field in HDF5 format and a XDMF file specifying its attributes. This format can be opened in Paraview for post-processing and visualization.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.set_X-Tuple{Any, Any}","page":"-","title":"FLOWVPM.set_X","text":"Set functions for particles\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.set_X-Tuple{ParticleField, Int64, Any}","page":"-","title":"FLOWVPM.set_X","text":"Set functions for particles in ParticleField\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.viscousdiffusion-Tuple{Any, FLOWVPM.ViscousScheme, Any}","page":"-","title":"FLOWVPM.viscousdiffusion","text":"Implementation of viscous diffusion scheme that gets called in the inner loop of the time integration scheme at each time step.\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.zeta_direct-Tuple{Any}","page":"-","title":"FLOWVPM.zeta_direct","text":"zeta_direct(pfield)\n\nEvaluates the basis function that the field exerts on itself through direct particle-to-particle interactions, saving the results under P.J[1:3].\n\n\n\n\n\n","category":"method"},{"location":"api/#FLOWVPM.zeta_fmm-Tuple{Any}","page":"-","title":"FLOWVPM.zeta_fmm","text":"zeta_fmm(pfield)\n\nEvaluates the basis function that the field exerts on itself through the FMM neglecting the far field, saving the results under P.W.\n\n\n\n\n\n","category":"method"},{"location":"#FLOWVPM.jl","page":"Introduction","title":"FLOWVPM.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FLOWVPM implements the reformulated vortex particle method (rVPM) developed in E. J. Alvarez' doctoral dissertation Reformulated Vortex Particle Method and Meshless Large Eddy Simulation of Multirotor Aircraft, 2022 [PDF][VIDEO]. The rVPM is a meshless CFD method solving the LES-filtered incompressible Navier-Stokes equations in their vorticity form. It uses a Lagrangian scheme, which not only avoids the hurdles of mesh generation, but it also conserves vortical structures over long distances with minimal numerical dissipation while being orders of magnitude faster than conventional mesh-based CFD.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The rVPM uses particles to discretize the Navier-Stokes equations, with the particles representing radial basis functions that construct a continuous vorticity/velocity field. The basis functions become the LES filter, providing a variable filter width and spatial adaption as the particles are convected and stretched by the velocity field. The local evolution of the filter width provides an extra degree of freedom to re-inforce conservations laws, which makes the reformulated VPM numerically stable.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This meshless CFD has several advantages over conventional mesh-based CFD. In the absence of a mesh, the rVPM (1) does not suffer from the conventional CFL condition, (2) does not suffer from the numerical dissipation introduced by a mesh, and (3) derivatives are calculated analytically rather than approximated through a stencil. Furthermore, rVPM is highly efficient since it uses computational elements only where there is vorticity rather than meshing the entire space, making it 100x faster than conventional mesh-based LES.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FLOWVPM is implemented in Julia, which is a modern, high-level, dynamic programming language for high-performance computing. Paraview is recommended for visualization of simulations.","category":"page"},{"location":"#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Fast-multipole acceleration through FastMultipole.jl\nThreaded CPU parallelization through OpenMP\nMeshless\nSecond-order spatial accuracy and third-order RK time integration\nNumerically stable by reshaping particles subject to vortex stretching\nSubfilter-scale (SFS) model of turbulence associated to vortex stretching\nSFS model coefficient computed dynamically or prescribed\nViscous diffusion through core spreading","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FLOWVPM is a stand-alone simulation framework, but it has also been integrated and used in the following codes: FLOWUnsteady, SUAVE,   VortexLattice","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This is an open-source project.   Improvements and further development by the community are accepted and encouraged.","category":"page"},{"location":"#Theory-and-Validation","page":"Introduction","title":"Theory and Validation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"E. J. Alvarez, 2022, Reformulated Vortex Particle Method and Meshless Large Eddy Simulation of Multirotor Aircraft. Doctoral Dissertation, Brigham Young University. [PDF][VIDEO]\nE. J. Alvarez & A. Ning, 2022, Reviving the Vortex Particle Method: A Stable Formulation for Meshless Large Eddy Simulation. In review. [PDF]\nE. J. Alvarez, J. Mehr, & A. Ning, 2022, FLOWUnsteady: An Interactional Aerodynamics Solver for Multirotor Aircraft and Wind Energy. AIAA AVIATION 2022 Forum. [PDF]","category":"page"},{"location":"#Sponsors","page":"Introduction","title":"Sponsors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"<img src=\"docs/img/sponsors00.jpg\" alt=\"Pic here\" style=\"width:900px\"/>","category":"page"},{"location":"#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Turbulent Jet: examples/roundjet/ [VIDEO1] [VIDEO2]   <img src=\"docs/media/img/vid-roundjet.jpg\" alt=\"Pic here\" style=\"width:600px\"/>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Vortex Ring Leapfrog: examples/vortexrings/   <img src=\"docs/media/img/vid-leapfrog.jpg\" alt=\"Pic here\" style=\"width:600px\"/>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Isolated Vortex Ring: examples/vortexrings/   <img src=\"docs/media/img/vid-vortexring.jpg\" alt=\"Pic here\" style=\"width:600px\"/>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Rotor in Hover: FLOWUnsteady [VIDEO]   <img src=\"docs/media/img/vid-rotor.jpg\" alt=\"Pic here\" style=\"width:600px\"/>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Ring with Toroidal Vorticity: [LINK] [VIDEO]   <img src=\"docs/media/img/vid-vortonring2.jpg\" alt=\"Pic here\" style=\"width:600px\"/>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"eVTOL Aircraft: FLOWUnsteady  [VIDEO]   <img src=\"docs/media/img/vahana2.jpg\" alt=\"Pic here\" style=\"width:600px\"/>","category":"page"},{"location":"#About","page":"Introduction","title":"About","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Main Developer    : Eduardo J Alvarez\nEmail             : Edo.AlvarezR@gmail.com\nWebsite           : edoalvarez.com\nCreated           : 2019\nLicense           : MIT","category":"page"}]
}
