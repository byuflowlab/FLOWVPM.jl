var documenterSearchIndex = {"docs":
[{"location":"guided/#Guided-Examples","page":"Guided Examples","title":"Guided Examples","text":"","category":"section"},{"location":"guided/#Vortex-Ring","page":"Guided Examples","title":"Vortex Ring","text":"","category":"section"},{"location":"guided/","page":"Guided Examples","title":"Guided Examples","text":"using FLOWVPM\nusing LinearAlgebra\n\nrm(\"ring\", recursive=true, force=true)\nmax_particles = 20\npfield = ParticleField(max_particles);\n\n# Ring parameters\nr = 1.0                             # vortex ring radius\nn_particles = max_particles         # number of particles in the ring\ncirculation = 10.0                   # circulation strength\n\nsigma = 2*pi*r / n_particles\nd_theta = 2*pi / n_particles\nomega = circulation / (pi*r^2)      # Average vorticity\ndr = pi*r^2 / n_particles\n\nfor i in 1:n_particles\n    theta = d_theta * (i-1)\n    X = [0.0, r*cos(theta), r*sin(theta)]\n    Gamma_hat = cross(X, [-1.0, 0.0, 0.0])\n    Gamma_hat = Gamma_hat / norm(Gamma_hat)\n    Gamma = omega * Gamma_hat * dr\n\n    add_particle(pfield, X, Gamma, sigma)\nend\n\nrun_vpm!(pfield, 0.1, 200; save_path=\"ring\")","category":"page"},{"location":"guided/#Leapfrogging-Vortex-Rings","page":"Guided Examples","title":"Leapfrogging Vortex Rings","text":"","category":"section"},{"location":"guided/","page":"Guided Examples","title":"Guided Examples","text":"using FLOWVPM\nusing LinearAlgebra\n\nfunction build_ring!(pfield, n_particles, r, circulation, x_center)\n    sigma = 2*pi*r / n_particles\n    d_theta = 2*pi / n_particles\n    omega = circulation / (pi*r^2)      # Average vorticity\n    dr = pi*r^2 / n_particles\n\n    for i in 1:n_particles\n        theta = d_theta * (i-1)\n        X = [x_center, r*cos(theta), r*sin(theta)]\n        Gamma_hat = cross(X, [-1.0, 0.0, 0.0])\n        Gamma_hat = Gamma_hat / norm(Gamma_hat)\n        Gamma = omega * Gamma_hat * dr\n\n        add_particle(pfield, X, Gamma, sigma)\n    end\n    return pfield\nend\n\nrm(\"leapfrog\", recursive=true, force=true)\nmax_particles = 40\npfield = ParticleField(max_particles);\n\n# Ring parameters\nr = 1.0                             # vortex ring radius\nn_particles = max_particles         # number of particles in the ring\ncirculation = 10.0                   # circulation strength\n\nbuild_ring!(pfield, max_particles/2, r, circulation, 0.0)\nbuild_ring!(pfield, max_particles/2, r, circulation, r)\n\nrun_vpm!(pfield, 0.1, 200; save_path=\"leapfrog\")","category":"page"},{"location":"guided/","page":"Guided Examples","title":"Guided Examples","text":"(Image: Leapfrog simulation)","category":"page"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"This tutorial runs through setting up a basic particle field and simulating the field.","category":"page"},{"location":"quickstart/#Create-a-ParticleField","page":"Quick Start","title":"Create a ParticleField","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"First, we create a particle field with a maximum of 10 particles.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using FLOWVPM\n\nmax_particles = 10\npfield = ParticleField(max_particles);","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"This creates an empty particle field that holds at most 10 particles.","category":"page"},{"location":"quickstart/#Add-Particles","page":"Quick Start","title":"Add Particles","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Now we can add particles to the field. Attempting to add more than max_particles will result in an error.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using Random\n\nfor i in 1:max_particles\n    add_particle(pfield, rand(3), rand(3), rand(1)[1])\nend\nprintln(\"Number of particles: \", pfield.np)","category":"page"},{"location":"quickstart/#Propogate-the-ParticleField","page":"Quick Start","title":"Propogate the ParticleField","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The particles in the ParticleField can be propogated single steps using FLOWVPM.nextstep(pfield, dt).","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"dt = 0.01\nFLOWVPM.nextstep(pfield, dt)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"For convinence run_vpm!(pfield, dt, nsteps) is also provided.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"dt = 0.01\nnsteps = 100\nrun_vpm!(pfield, dt, nsteps)","category":"page"},{"location":"quickstart/#Remove-Particles","page":"Quick Start","title":"Remove Particles","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"If we want to remove particles from the field we can use the remove_particle(pfield, i) function where i is the index of the particle we want removed.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"for i in pfield.np:-1:1\n    remove_particle(pfield, i)\nend\nprintln(\"Number of particles after removal \", pfield.np)","category":"page"},{"location":"rVPM/#Reformulated-VPM","page":"Theory","title":"Reformulated VPM","text":"","category":"section"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"The following is an excerpt from  E. J. Alvarez & A. Ning (2022), \"Meshless Large Eddy Simulation of Rotor-Wing Interactions Through the Reformulated Vortex Particle Method,\" (in review).","category":"page"},{"location":"rVPM/#Vorticity-Navier-Stokes","page":"Theory","title":"Vorticity Navier-Stokes","text":"","category":"section"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"In recent work[1][2], a new formulation of the vortex particle method (VPM) has been derived from the LES-filtered Navier-Stokes equations. The new method, referred to as the reformulated VPM or rVPM, is an LES that is both numerically stable and meshless, and is able to accurately resolve mean and fluctuating large-scale features of turbulent flow with minimal computational effort. Hereby we concisely summarize the governing equations of the reformulated VPM, and the reader is referred to Ref.[1] and the doctoral dissertation[2] accompanying this work for a detailed derivation of the method.","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"The reformulated VPM uses a Lagrangian scheme to solve the vorticity form of the LES-filtered Navier-Stokes equations","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"beginalign\n        fracpartial overline omega_i partial t\n        + overline u_j  fracpartial overline omega_i partial x_j\n     =\n        overline omega_j  fracpartial overline u_i partial x_j\n    +\n        nu nabla^2 overline omega_i  -\n        fracpartial T_ijpartial x_j +\n        fracpartial T_ijpartial x_j\nendalign","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"where the bar denotes the filter operator,[a] and T_ij equiv overline u_i omega_j  - overline u_i   overline omega_j  is the subfilter-scale (SFS) vorticity stress capturing the interactions between large-scale dynamics and SFS dynamics. The term fracpartial T_ijpartial x_j represents the SFS contributions arising from the advective term (vorticity advection), while fracpartial T_ijpartial x_j represents the contributions arising from vortex stretching. For simplicity, Eq. (1) is written in vector notation as","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"beginalign\n    fractextd textd t overline boldsymbolomega \n    = left( overline boldsymbolomega  cdot nabla right) overline mathbfu  +\n    nu nabla^2 overline boldsymbolomega \n    - mathbfE_mathrmadv - mathbfE_mathrmstr\nendalign","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"where left( mathbfE_mathrmadv right)_i equiv fracpartial T_ijpartial x_j is the SFS vorticity advection, left( mathbfE_mathrmstr right)_i equiv - fracpartial T_ijpartial x_j is the SFS vortex stretching, and the fractextd textd t operator is the linearized version of the filtered material derivative, fractextd textd t () equiv fracpartial partial t() + (overline bf u  cdot nabla)(). Notice that casting the Navier-Stokes equation into this vorticity form gets rid of all dependance on pressure. Furthermore, this equation depends on boldsymbolomega alone since bfu can be calculated directly from boldsymbolomega = nabla times bfu through the Biot-Savart law.","category":"page"},{"location":"rVPM/#particlediscretization","page":"Theory","title":"Particle Discretization","text":"","category":"section"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"The material derivative in Eq. (2) and the material-conservative nature of the vorticity makes the boldsymbolomega field especially well fit for a Lagrangian description. The unfiltered boldsymbolomega field is discretized with singular vortex particles of positions bf x_p and coefficients boldsymbolGamma_p (called vortex strength), approximating boldsymbolomega as","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"beginalign  labeleqparticledirac\n    boldsymbolomega(bf xt) approx sum\n        limits_p boldsymbolGamma_p (t)\n            delta  (bf x - bf x_p(t))\nendalign","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"where delta is the Dirac delta. Applying the filter operator,","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"beginalign*\n        overline boldsymbolomega  left( mathbfx right)\n     =\n        intlimits_-infty^infty\n            boldsymbolomegaleft( mathbfy right)\n            zeta_sigma(mathbfx-mathbfy)\n        mathrmdmathbfy\n      \n    approx\n        intlimits_-infty^infty\n            left(\n                sumlimits_p\n                    boldsymbolGamma_p\n                    delta (textbf y - textbf x_p)\n            right)\n            zeta_sigma(mathbfx-mathbfy)\n        mathrmdmathbfy\nendalign*","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"the Dirac delta collapses the integral, obtaining an approximation of the filtered vorticity field as","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"beginalign  labeleqparticleblob\n        overlineboldsymbolomegaleft( mathbfxt right)\n     approx\n        sumlimits_p\n            boldsymbolGamma_p (t)\n            zeta_sigma_p(mathbfx-mathbfx_p(t))\nendalign","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"where zeta_sigma(mathbfx) equiv frac1sigma^3 zeta left(fracVert mathbfx Vertsigma right) is the filter kernel of width sigma and radial basis zeta. As seen in Eq. (4), the filter operator has the effect of spreading the vortex strength boldsymbolGamma_p in space, regularizing the singularity originally introduced by the Dirac delta. Thus, the filter kernel takes the role of a basis function that is used to discretize overlineboldsymbolomega through particles. We let the filter width sigma (here on called smoothing radius or core size) change in time and space according to the evolution of each individual particle. The particle field constructs a continuous vorticity field through radial basis functions as given by Eq. (4), and also a continuous velocity field by inverting the relation overlineboldsymbolomega = nabla times overlinemathbfu as","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"beginalign  labeleqUreg\n        overline mathbfu left( mathbfx right)\n    =\n        - frac14pisumlimits_p g_sigma_pleft( mathbfx-mathbfx_p right)\n            fracmathbfx-mathbfx_pVertmathbfx-mathbfx_pVert^3\n            times\n            boldsymbolGamma_p\nendalign","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"where g_sigma is the regularizing function[3] associated with the filter kernel zeta_sigma. Hence, all fluid properties—like overlinemathbfu and its spatial derivatives—are continuous and can be computed analytically.","category":"page"},{"location":"rVPM/#Governing-Equations","page":"Theory","title":"Governing Equations","text":"","category":"section"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"Similar to the process that led from Eq. (3) to Eq. (4), we use singular particles to discretize the LES-filtered vorticity equation given in Eq. (2), and arrive to the governing equations of the reformulated VPM:","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"beginalign\n     labeleqrvpmgedxdt\n     bullet quad\n    \n        fractextdtextdtbf x_p\n        =\n        overlinemathbfu(bf x_p)\nendalign","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"beginalign\n       labeleqrvpmgedGammadt\n    beginsplit\n         bullet quad\n         fracmathrmd mathrmd t boldsymbolGamma_p\n        =\n            left(\n                boldsymbolGamma_p cdot nabla\n            right)\n            overlinemathbfu (bf x_p)\n            -\n            fracg + ffrac13 + f\n            left\n                left\n                    left(\n                            boldsymbolGamma_p  cdot nabla\n                        right)\n                        overlinemathbfu small (bf x_p)\n                right\n                cdot hatboldsymbolGamma_p\n            right hatboldsymbolGamma_p\n        \n         qquad qquad \n        qquad qquad quad \n            - fracC_dzeta_sigma_p (bf 0)\n            left\n                mathbfE_mathrmstr (bf x_p)\n                -\n                fracffrac13 + f\n                left(\n                    mathbfE_mathrmstr (bf x_p) cdot hatboldsymbolGamma_p\n                right) hatboldsymbolGamma_p\n            right\n    endsplit\nendalign","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"beginalign\n       labeleqrvpmgedsigmadt\n     bullet quad\n    \n        fracmathrmd mathrmd t sigma_p\n        =\n        - left(\n            fracg + f1 + 3f\n        right)\n        fracsigma_pVert boldsymbolGamma_p Vert\n            left\n                left(\n                        boldsymbolGamma_p  cdot nabla\n                    right)\n                    overlinemathbfu small (bf x_p)\n            right\n            cdot hatboldsymbolGamma_p\n        +\n        left(\n            fracf1 + 3f\n        right)\n        fracsigma_pVert boldsymbolGamma_p Vert\n        fracC_dzeta_sigma_p (bf 0)\n        mathbfE_mathrmstr (bf x_p) cdot hatboldsymbolGamma_p\nendalign","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"beginalign\n       labeleqrvpmgeviscous\n     bullet quad\n    \n        left(\n            fractextd textd t overline boldsymbolomega \n        right)_mathrmviscous\n        =\n        nu nabla^2 overline boldsymbolomega \nendalign","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"where Eq. (6) resolves vorticity advection by convecting the particles, Eq. (7) governs the evolution of vortex strength, and Eq. (8) governs the evolution of particle size. Eq. (7) in conjunction with Eqs. (6) and (8) resolve the inviscid part of the LES-filtered vorticity Navier-Stokes equation, while the viscous part in Eq. (9) can be resolved through any of the schemes previously proposed in the literature (e.g., vortex redistribution method, particle strength exchange, or core spreading).","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"The main headway of the reformulated VPM over the classic VPM is that rVPM uses the particle size, or fracmathrmd mathrmd t sigma_p, as an extra degree of freedom to reinforce conservation laws. As shown in References [1] and [2], momentum and mass conservation leads to f = 0 and g = frac15, and Eqs. (7) and (8) become","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"beginalign*\n     bullet quad\n     fracmathrmd mathrmd t boldsymbolGamma_p\n    =\n        left(\n            boldsymbolGamma_p cdot nabla\n        right)\n        overline mathbfu  (mathbfx_p)\n        -\n        frac35\n        left\n            left\n                left(\n                        boldsymbolGamma_p  cdot nabla\n                    right)\n                    overline mathbfu  small (mathbfx_p)\n            right\n            cdot hatboldsymbolGamma_p\n        right hatboldsymbolGamma_p\n        - fracC_dzeta_sigma_p (mathbf0)\n            mathbfE_mathrmstr (mathbfx_p)\n    \n     bullet quad\n    \n        fracmathrmd mathrmd t sigma_p\n        =\n        -\n        frac15\n        fracsigma_pVert boldsymbolGamma_p Vert\n            left\n                left(\n                        boldsymbolGamma_p  cdot nabla\n                    right)\n                    overline mathbfu  small (mathbfx_p)\n            right\n            cdot hatboldsymbolGamma_p\nendalign*","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"which is the formulation referred to as the \"reformulated VPM.\" Notice that when f = g = 0 and mathbfE_mathrmstr is neglected, Eqs. (7) and (8) collapse back to the classic VPM equations, making these equations a generalization of the classic method. In Reference [2] is shown that the classic VPM turns out to violate both conservation of momentum and mass when it assumes fracmathrmd mathrmd t sigma_p = 0, which explains the tendency of the classic VPM to be numerically unstable. Furthermore, notice that the rVPM equations do not require more computation than the classic VPM: when SFS effects are neglected (mathbfE_mathrmstr=0), both fracmathrmd sigma_p mathrmdt and fracmathrmd boldsymbolGamma_pmathrmd t are calculated directly and solely from vortex stretching, left( boldsymbolGamma_p cdot nabla  right) overlinemathbfu (bf x_p).","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"For an in-depth derivation of the rVPM governing equations, see Chapters 1 and 2 in Alvarez' Dissertation.[2]","category":"page"},{"location":"rVPM/#sfsmodel","page":"Theory","title":"Turbulence Model","text":"","category":"section"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"Turning our attention back to the SFS stress tensor T_ij, the accuracy of LES hinges on the modeling of this tensor. Its divergence represents the rate at which enstrophy—a measure of rotational kinetic energy—is transferred from resolved scales to subfilter scales (diffusion) and from subfilter scales to resolved scales (backscatter). In vortex methods, the most common SFS models use variants of the Smagorinsky eddy-viscosity model formulated for the vorticity stress.[4][5] However, these models are developed on the basis of homogeneous isotropic turbulence, which makes them overly diffusive in simulations with coherent vortical structures. In Reference [1], the following anisotropic model of SFS vortex stretching is proposed:","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"beginalign*  labeleqEstr\n        mathbfE_mathrmstr left( mathbfx right)\n    approx\n        sumlimits_q\n            zeta_sigma(mathbfx-mathbfx_q)\n            left(\n                boldsymbolGamma_q cdot nabla\n            right)\n            left(\n                overlinemathbfu left( mathbfx right) - overlinemathbfu left( mathbfx_q right)\n            right)\nendalign*","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"The model coefficient C_d is calculated dynamically at the position of every particle as","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"beginalign*  labeleqCdGammaMLave\n        C_d\n    =\n        frac\n            left boldsymbolGamma_p cdot mathbfL right\n        \n            left boldsymbolGamma_p cdot mathbfm right\n        \nendalign*","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"where left cdot right denotes an integration along Lagrangian trajectories[6], and","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"beginalign*\n    \n        mathbfm =\n            fracsigma^3zeta(0) fracpartial mathbfE_mathrmstr partial sigma (mathbfx_p)\n    \n    \n        mathbfL =\n            frac3sigma\n            left( boldsymbolGamma_p cdot nabla right)\n            left(\n                mathbfu (mathbfx_p) - overlinemathbfu (mathbfx_p)\n            right)\n            +\n            left( boldsymbolGamma_p cdot nabla right)\n            fracpartial overlinemathbfu partial sigma  (mathbfx_p)\nendalign*","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"This dynamic procedure is based on a simultaneous balance of enstrophy-production and derivatives between true and modeled SFS contributions. Backscatter is controlled by clipping the model coefficient to C_d=0 whenever the condition C_d boldsymbolGamma_p cdot mathbfE_mathrmstr (mathbfx_p) geq 0 is not satisfied. This results in a low-dissipation SFS model that uses vortex stretching as the physical mechanism for turbulence, which is well suited for flows with coherent vortical structures where the predominant cascade mechanism is vortex stretching.","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"For an in-depth derivation of the SFS model, see Chapter 3 in Alvarez' Dissertation.[2]","category":"page"},{"location":"rVPM/#Immersed-Vorticity","page":"Theory","title":"Immersed Vorticity","text":"","category":"section"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"In order to immerse the vorticity of solid boundaries into the LES-filtered Navier-Stokes equations, the filtered vorticity field overlineboldsymbolomega(mathbfx t) is decomposed into a free-vorticity field overlineboldsymbolomega_mathrmfree(mathbfx t) and a bound-vorticity field overlineboldsymbolomega_mathrmbound(mathbfx t) as","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"beginalign*\n        overlineboldsymbolomega\n    =\n        overlineboldsymbolomega_mathrmfree + overlineboldsymbolomega_mathrmbound\nendalign*","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"Both components can be discretized with vortex particles as","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"beginalign*\n        overlineboldsymbolomega (mathbfx)\n    =\n        underbrace\n            sumlimits_p boldsymbolGamma_p zeta_sigma_p left( mathbfx - mathbfx_p right)\n        _overlineboldsymbolomega_mathrmfree\n        +\n        underbrace\n            sumlimits_b boldsymbolGamma_b zeta_sigma_b left( mathbfx - mathbfx_b right)\n        _overlineboldsymbolomega_mathrmbound\nendalign*","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"where the particles discretizing the free-vorticity field evolve according to the rVPM governing equations, Eqs. (6) through (9), while the ones discretizing the bound-vorticity are embedded on the solid boundaries and their strength is calculated by actuator models derived in Alvarez' Dissertation,[2] Chapter 6. The velocity field is obtained by inverting the relation boldsymbolomega = nabla times mathbfu, resulting in","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"beginalign*\n        overline mathbfu left( mathbfx right)\n    =\n        underbrace\n            sumlimits_p g_sigma_pleft( mathbfx-mathbfx_p right)\n                mathbfKleft( mathbfx-mathbfx_p right)\n                times\n                boldsymbolGamma_p\n        _overlinemathbfu_mathrmfree\n        +\n        underbrace\n            sumlimits_b g_sigma_bleft( mathbfx-mathbfx_b right)\n                mathbfKleft( mathbfx-mathbfx_b right)\n                times\n                boldsymbolGamma_b\n        _overlinemathbfu_mathrmbound\nendalign*","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"which includes the velocity induced by both free and bound vorticity components, and where mathbfKleft( mathbfx right) equiv - frac14pi fracmathbfxVertmathbfxVert^3. Thus, the evolution of the free particles is influenced by the vorticity immersed at the solid boundaries, affecting their convection and vortex stretching through the velocity field induced by the bound particles.","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"The immersed vorticity not only affects the evolution of existing free vorticity, but it also creates new free vorticity at the boundary through viscous diffusion. In reality, vorticity is created in the boundary layer, it builds up as it travels along the surface, and it is eventually shed off the surface either by the Kutta condition at the trailing edge, flow separation, or other turbulent mechanisms. On a slender body, the vorticity can be assumed to be shed at the trailing edge.","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"In most models inside FLOWUnsteady, instead of creating vorticity through the viscous diffusion equation, the immersed vorticity is shed along a prescribed trailing edge. This approach neglects the wake created by flow separation. However, the effects of flow separation on loading (like the drop in lift and increase in pressure drag on a stalled airfoil) can still be captured whenever lookup airfoil tables are used.","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"compat: Recommended\nFor an in-depth discussion of the actuator line and surface models implemented in FLOWUnsteady, see Chapter 6 in Alvarez' Dissertation.[2]","category":"page"},{"location":"rVPM/#Other-Schemes","page":"Theory","title":"Other Schemes","text":"","category":"section"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"In the default settings of FLOWUnsteady, vortex stretching is resolved with the transposed scheme and the divergence of the vorticity field is treated through the relaxation scheme developed by Pedrizzeti.[7] The time integration of the governing equations is done through a low-storage third-order Runge-Kutta scheme. A Gaussian kernel is used as the LES filter zeta_sigma (or VPM radial basis function). Like the classic VPM, the reformulated VPM is spatially second-order accurate in the convective term when a Gaussian basis is used. Viscous diffusion is solved through the core spreading method coupled with the radial basis function interpolation approach for spatial adaptation developed by Barba.[8] This viscous scheme has second-order spatial convergence, while showing linear convergence when coupled with spatial adaptation. The fast multipole method (FMM) is used for the computation of the regularized Biot-Savart law, approximating the velocity field and vortex stretching through spherical harmonics with computational complexity mathcalO(N), where N is the number of particles. The FMM computation of vortex stretching is performed analytically under the Lamb-Helmholtz decomposition[9] as implemented in the open-source, parallelized code FastMultipole. FLOWVPM and FLOWUnsteady are implemented in the Julia language, which is a modern, high-level, dynamic programming language for high-performance computing.","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"compat: Recommended\nFor an in-depth discussion of the numerical schemes implemented in FLOWUnsteady, see Chapter 4 in Alvarez' Dissertation.[2]","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"[1]: E. J. Alvarez & A. Ning (2022), \"Reviving the Vortex Particle Method: A Stable Formulation for Meshless Large Eddy Simulation,\" (in review). [PDF]","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"[2]: E. J. Alvarez (2022), \"Reformulated Vortex Particle Method and Meshless Large Eddy Simulation of Multirotor Aircraft,\" Doctoral Dissertation, Brigham Young University. [VIDEO] [PDF]","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"[3]: Winckelmans, G., and Leonard, A., “Contributions to Vortex Particle Methods for the Computation of Three-Dimensional Incompressible Unsteady Flows,” Journal of Computational Physics, Vol. 109, No. 2, 1993.","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"[4]: Winckelmans, G. S., “Some progress in large-eddy simulation using the 3D vortex particle method,” CTR Annual Research Briefs, , No. 2, 1995, pp. 391–415.","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"[5]: Mansfield, J. R., Knio, O. M., and Meneveau, C., “A Dynamic LES Scheme for the Vorticity Transport Equation: Formulation and a Priori Tests,” Journal of Computational Physics, Vol. 145, No. 2, 1998, pp. 693–730.","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"[6]: Meneveau, C., Lund, T. S., and Cabot, W. H., “A Lagrangian dynamic subgrid-scale model of turbulence,” Journal of Fluid Mechanics, Vol. 319, No. -1, 1996, p. 353.","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"[7]: Pedrizzetti, G., “Insight into singular vortex flows,” Fluid Dynamics Research, Vol. 10, No. 2, 1992, pp. 101–115.","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"[8]: Barba, L. A., Leonard, A., and Allen, C. B., “Advances in viscous vortex methods - Meshless spatial adaption based on radial basis function interpolation,” International Journal for Numerical Methods in Fluids, Vol. 47, No. 5, 2005, pp. 387–421. Also, Barba, L. A., “Vortex Method for computing high-Reynolds number Flows: Increased accuracy with a fully mesh-less formulation,” California Institute of Technology, Vol. 2004, 2004.","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"[9]: Gumerov, Nail A and Duraiswami, Ramani, \"Efficient FMM Accelerated Vortex Methods in Three Dimensions via the Lamb–Helmholtz Decomposition\", Journal of Computational Physics, Vol. 240, 2013, pp. 310-328.","category":"page"},{"location":"rVPM/","page":"Theory","title":"Theory","text":"[a]: Let phi be a field and zeta_sigma a filter kernel with cutoff length sigma, the filter operator is defined as overlinephi left( mathbfx right) equiv intlimits_-infty^infty phi(mathbfy)zeta_sigma(mathbfx-mathbfy) mathrmdmathbfy.","category":"page"},{"location":"advanced/#Advanced-Usage","page":"Advanced Usage","title":"Advanced Usage","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"For more advanced examples please see the examples folder.","category":"page"},{"location":"advanced/#Accessing-the-ParticleField","page":"Advanced Usage","title":"Accessing the ParticleField","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"FLOWVPM provides getter and setter functions for particles. Getter functions take the form get_property(P) where P is a particle, or get_property(pfield::ParticleField, i::Int) where i is the particle index. Getter functions return views. Setter functions take the from set_property(P, val) and set_property(pfield, i, val) where val is the new value to be set and is applied via broadcasting. Getter and setter functions are used by replacing \"property\" with the desired particle property such as get_X(P). The following are the particle properties: ","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"X: position\nGamma: vortex strength\nsigma: radius\nvol: volume\ncirculation: circulation\nU: velocity\nvorticity: vorticity \nJ: velocity gradient\nM: auxiliary computational storage\nC: SFS model parameters\nstatic: tag indicating whether this particle's states should evolve in time or not (sometimes used to represent solid bodies)\nPSE: Storage needed for ParticleStrengthExchange\nSFS: Storage of SFS values","category":"page"},{"location":"advanced/#Particle-Field-Settings","page":"Advanced Usage","title":"Particle Field Settings","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Here we provide details on all relevant keyword setting for a ParticleField.","category":"page"},{"location":"advanced/#formulation","page":"Advanced Usage","title":"formulation","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The VPM formulation to be used","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"rVPM: The reformulated VPM equations (default).\ncVPM: The classic VPM equations.\nformulation_tube_continuity: VPM equations derived from tube conservation of mass.\nformulation_tube_momentum: VPM equations derived from tube conservation of momentum.","category":"page"},{"location":"advanced/#viscous","page":"Advanced Usage","title":"viscous","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The viscous model used when propagating particles. Generally, aerodynamic simulations do not require viscous modeling.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Inviscid: Uses no viscous modeling for the particles (default).\nCoreSpreading: Uses a core spreading viscous model in which particles grow in size at each step. After a defined amount of time the particle size is reset and the particle strength recalculated to maintain the vorticity field strength.\nParticleStrengthExchange: Uses particle strength exchange to simulate viscosity.","category":"page"},{"location":"advanced/#kernel","page":"Advanced Usage","title":"kernel","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Describes how vorticity is distributed by the vortex particles.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"singular: Singular vortex kernel.\ngaussian: Gaussian vortex kernel.\ngaussianerf: Gaussian error function vortex kernel (default).\nwinckelmans: Winckelman vortex kernel","category":"page"},{"location":"advanced/#UJ","page":"Advanced Usage","title":"UJ","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Determines how the n-body particle interaction is solved. Users can provide custom UJ functions if desired.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"UJ_fmm: Uses the fast multipole method to solve the n-body problem (default).\nUJ_direct: Loops through all particle interactions directly.","category":"page"},{"location":"advanced/#Uinf","page":"Advanced Usage","title":"Uinf","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The freestream fluid velocity. Defaults to SVector{3,Float64}(0,0,0).","category":"page"},{"location":"advanced/#SFS","page":"Advanced Usage","title":"SFS","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The subfilter-scale (SFS) model used in the reformulated VPM equations. The SFS model simulated the turbulent energy cascade. For simulations with little turbulence the model may be unnecessary. Custom modifications can be made, setting the coefficient or the alpha used is possible.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"noSFS: No SFS model is used (default).\nSFS_Cs_nobackscatter: Uses a constant coefficient for the SFS model.\nSFS_Cd_twolevel_nobackscatter: Uses a dynamic coefficient for the SFS model. Sets alpha=0.999. Recommended for high fidelity modeling.\nSFS_Cd_threelevel_nobackscatter: Uses a dynamic coefficient for the SFS model. Sets alpha=0.667, which reduces the effect of the SFS significantly.","category":"page"},{"location":"advanced/#integration","page":"Advanced Usage","title":"integration","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The time integration scheme used in propogating particles","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"euler: Uses an euler time stepping scheme.\nrungekutta3: Uses a low storage RK3 time stepping scheme (default).","category":"page"},{"location":"advanced/#transposed","page":"Advanced Usage","title":"transposed","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Determines how the stretching term is stored. Defaults to true. There is no need for users to modify this value.","category":"page"},{"location":"advanced/#relaxation","page":"Advanced Usage","title":"relaxation","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"To avoid numerical instability the particles are relaxed in order to ensure the field is divergence free.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"norelaxation: Does not relax the particles.\npedrizzetti: Relaxation scheme where the vortex strength is aligned with the local vorticity. (default).\ncorrectedpedrizzetti: Relaxation scheme where the vortex strength is aligned with the local vorticity. This version fixes the error in Pedrizzetti's relaxation that made the strength","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"to continually decrease over time.","category":"page"},{"location":"advanced/#fmm","page":"Advanced Usage","title":"fmm","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Settings for the fast multipole solver. Defaults autotune the FMM so that the absolute and relative tolerance of the velocity calculations are within 1e-3. See the the API for detailed settings","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"FMM","category":"page"},{"location":"advanced/#useGPU","page":"Advanced Usage","title":"useGPU","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Determines whether or not to use GPU acceleration to solve the n-body problem. Defaults to CPU usage. Still experimental and does not work on SFS calculation, only works on NVIDIA GPUs. To allow GPU usage set to values greater than 0.","category":"page"},{"location":"advanced/#Code-Integration","page":"Advanced Usage","title":"Code Integration","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"For examples of integrating FLOWVPM into other codes please see FLOWUnsteady and VortexLattice","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#ParticleField","page":"Reference","title":"ParticleField","text":"","category":"section"},{"location":"reference/#FLOWVPM.ParticleField","page":"Reference","title":"FLOWVPM.ParticleField","text":"ParticleField(maxparticles::Int, R=FLOAT_TYPE; <keyword arguments>)\n\nCreate a new particle field with maxparticles particles. The particle field is created with the default values for the other parameters.\n\nArguments\n\nmaxparticles::Int           : Maximum number of particles in the field.\nR=FLOAT_TYPE                : Type of the particle field. Default is FLOAT_TYPE.\nformulation                 : VPM formulation. Default is rVPM.\nviscous::ViscousScheme      : Viscous scheme. Default is Inviscid(). With rVPM formulation,                                   a viscous scheme is not required for numerical stability.\nnp::Int                     : Number of particles currently in the field. Default is 0. (user should not modify)\nnt::Int                     : Current time step number. Default is 0. (user should not modify)\nt::Real                     : Current time. Default is 0.\ntransposed::Bool            : If true, the transposed scheme is recommended for stability.                               Default is true. (user should not modify)\nfmm::FMM{TEPS}              : Fast-multipole settings. Default is FMM().\nM::Array{R, 1}              : Memory for computations. Default is zeros(R, 4). (user should not modify)\ntoggle_rbf::Bool            : If true, the FMM computes the vorticity field rather than velocity field.                                   This is used as an internal switch for the FMM.                                   Default is false. (user should not modify)\ntoggle_sfs::Bool            : If true, the FMM computes the stretching term for the SFS model.                                   This is used as an internal switch for the FMM.                                   Default is false. (user should not modify)\nSFS::S                      : Subfilter-scale contributions scheme. Default is noSFS.\nkernel::Tkernel             : Vortex particle kernel. Default is gaussianerf.\nUJ::TUJ                     : Particle-to-particle calculation. Default is UJ_fmm.\nUinf::TUinf                 : Uniform freestream function Uinf(t). Default is no freestream.\nrelaxation::TR              : Relaxation scheme. Default is pedrizzetti.\nintegration::Tintegration   : Time integration scheme. Default is rungekutta3. The only other                                   option is euler.\nuseGPU::Int                 : Run on GPU if >0, CPU if 0. Default is 0. (Experimental and does not                                    accelerate SFS calculations)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Formulations","page":"Reference","title":"Formulations","text":"","category":"section"},{"location":"reference/#FLOWVPM.rVPM","page":"Reference","title":"FLOWVPM.rVPM","text":"rVPM\n\nAlias for the reformulated VPM formulation. Enforces conservation of mass  and momentum for a spherical fluid element and is the default formulation  (f=0, g=1/5)\n\n\n\n\n\n","category":"constant"},{"location":"reference/#FLOWVPM.cVPM","page":"Reference","title":"FLOWVPM.cVPM","text":"cVPM\n\nAlias for the classic VPM formulation.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#FLOWVPM.formulation_tube_continuity","page":"Reference","title":"FLOWVPM.formulation_tube_continuity","text":"formulation_tube_continuity\n\nAlias for mass conserving tube formulation. Enforces conservation of mass  for a vortex tube (f=1/2, g=0)\n\n\n\n\n\n","category":"constant"},{"location":"reference/#FLOWVPM.formulation_tube_momentum","page":"Reference","title":"FLOWVPM.formulation_tube_momentum","text":"formulation_tube_momentum\n\nAlias for momentum conserving tube formulation. Enforces conservation  of momentum for a vortex tube (f=1/4, g=1/4)\n\n\n\n\n\n","category":"constant"},{"location":"reference/#Viscous-Models","page":"Reference","title":"Viscous Models","text":"","category":"section"},{"location":"reference/#FLOWVPM.Inviscid","page":"Reference","title":"FLOWVPM.Inviscid","text":"Inviscid()\n\nCreates an inviscid scheme with zero kinematic viscosity.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FLOWVPM.CoreSpreading","page":"Reference","title":"FLOWVPM.CoreSpreading","text":"CoreSpreading(nu, sgm0, zeta::Tzeta=zeta_fmm; <keyword arguments>)\n\nCreates a core spreading viscous scheme with the given parameters.\n\nArguments\n\nnu::Real Kinematic viscosity.\nsgm0::Real Core size after reset.\nzeta::Function = zeta_fmm Basis function evaluation method.\nbeta::Real = 1.5 Maximum core size growth σ/σ_0.\nitmax::Int = 15 Maximum number of RBF iterations.\ntol::Real = 1e-3 RBF interpolation tolerance.\niterror::Bool = true Throw error if RBF didn't converge.\nverbose::Bool = false Verbose on RBF interpolation.\nv_lvl::Int = 2 Verbose printing tab level.\ndebug::Bool = false Print verbose for debugging.\nrbf::Function = rbf_conjugategradient RBF function.\nrr0s::Array{R, 1} = zeros(R, 3) Initial field residuals.\nrrs::Array{R, 1} = zeros(R, 3) Current field residuals.\nprev_rrs::Array{R, 1} = zeros(R, 3) Previous field residuals.\npAps::Array{R, 1} = zeros(R, 3) pAp product.\nalphas::Array{R, 1} = zeros(R, 3) Alpha coefficients.\nbetas::Array{R, 1} = zeros(R, 3)\nflags::Array{Bool, 1} = zeros(Bool, 3)\n\n\n\n\n\n","category":"type"},{"location":"reference/#FLOWVPM.ParticleStrengthExchange","page":"Reference","title":"FLOWVPM.ParticleStrengthExchange","text":"ParticleStrengthExchange(nu; <keyword arguments>)\n\nCreates a particle strength exchange viscous scheme with the given parameters.\n\nArguments\n\nnu::Real Kinematic viscosity.\nrecalculate_vols::Bool = true Whether to recalculate particle volumes.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FMM","page":"Reference","title":"FMM","text":"","category":"section"},{"location":"reference/#FLOWVPM.FMM","page":"Reference","title":"FLOWVPM.FMM","text":"`FMM(; p::Int=4, ncrit::Int=10, theta::Real=0.5, shrink_recenter::Bool=true,\n      relative_tolerance::Real=1e-3, absolute_tolerance::Real=1e-6,\n      autotune_p::Bool=true, autotune_ncrit::Bool=true,\n      autotune_reg_error::Bool=true, default_rho_over_sigma::Real=1.0)`\n\nParameters for FMM solver.\n\nArguments\n\np       : Order of multipole expansion.\nncrit   : Maximum number of particles per leaf.\ntheta   : Neighborhood criterion. This criterion defines the distance               where the far field starts. The criterion is that if θ*r < R1+R2               the interaction between two cells is resolved through P2P, where               r is the distance between cell centers, and R1 and R2 are each               cell radius. This means that at θ=1, P2P is done only on cells               that have overlap; at θ=0.5, P2P is done on cells that their               distance is less than double R1+R2; at θ=0.25, P2P is done on               cells that their distance is less than four times R1+R2; at               θ=0, P2P is done on all cells.\nshrink_recenter : If true, shrink and recenter multipole expansions to account for nonzero particle radius.\nrelative_tolerance : Relative error tolerance for FMM calls.\nabsolute_tolerance : Absolute error tolerance fallback for FMM calls in case relative tolerance becomes too small.\nautotune_p : If true, automatically adjust p to optimize performance.\nautotune_ncrit : If true, automatically adjust ncrit to optimize performance.\nautotune_reg_error : If true, constrain regularization error in FMM calls.\ndefault_rho_over_sigma : Default value for ρ/σ in FMM calls (unused if autotune_reg_error is true).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Subfilter-Scale-Models","page":"Reference","title":"Subfilter-Scale Models","text":"","category":"section"},{"location":"reference/#FLOWVPM.noSFS","page":"Reference","title":"FLOWVPM.noSFS","text":"noSFS\n\nAlias for the no subfilter-scale model.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#FLOWVPM.SFS_Cs_nobackscatter","page":"Reference","title":"FLOWVPM.SFS_Cs_nobackscatter","text":"SFS_Cs_nobackscatter\n\nAlias for the Constant SFS model with no backscatter.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#FLOWVPM.SFS_Cd_twolevel_nobackscatter","page":"Reference","title":"FLOWVPM.SFS_Cd_twolevel_nobackscatter","text":"SFS_Cd_twolevel_nobackscatter\n\nAlias for the Dynamic SFS model with two levels and no backscatter. This is the recommended SFS model for high fidelity modeling.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#FLOWVPM.SFS_Cd_threelevel_nobackscatter","page":"Reference","title":"FLOWVPM.SFS_Cd_threelevel_nobackscatter","text":"SFS_Cd_threelevel_nobackscatter\n\nAlias for the Dynamic SFS model with three levels and no backscatter. This is similar to the two level version but uses a lower value of alpha (0.667).\n\n\n\n\n\n","category":"constant"},{"location":"reference/#Particle-Kernels","page":"Reference","title":"Particle Kernels","text":"","category":"section"},{"location":"reference/#FLOWVPM.singular","page":"Reference","title":"FLOWVPM.singular","text":"singular\n\nAlias for the singular kernel.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#FLOWVPM.gaussian","page":"Reference","title":"FLOWVPM.gaussian","text":"gaussian\n\nAlias for the Gaussian kernel.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#FLOWVPM.gaussianerf","page":"Reference","title":"FLOWVPM.gaussianerf","text":"gaussianerf\n\nAlias for the Gaussian error function kernel.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#FLOWVPM.winckelmans","page":"Reference","title":"FLOWVPM.winckelmans","text":"winckelmans\n\nAlias for the Winckelmans kernel.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#Relaxation-Schemes","page":"Reference","title":"Relaxation Schemes","text":"","category":"section"},{"location":"reference/#FLOWVPM.norelaxation","page":"Reference","title":"FLOWVPM.norelaxation","text":"norelaxation\n\nAlias for the no relaxation scheme.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#FLOWVPM.pedrizzetti","page":"Reference","title":"FLOWVPM.pedrizzetti","text":"pedrizzetti\n\nAlias for the Pedrizzetti relaxation scheme.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#FLOWVPM.correctedpedrizzetti","page":"Reference","title":"FLOWVPM.correctedpedrizzetti","text":"correctedpedrizzetti\n\nAlias for the corrected Pedrizzetti relaxation scheme. Is a modification  to the pedrizzetti relaxation that preserves the vortex strength magnitude.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#Time-Integration","page":"Reference","title":"Time Integration","text":"","category":"section"},{"location":"reference/#FLOWVPM.euler","page":"Reference","title":"FLOWVPM.euler","text":"euler(pfield::ParticleField, dt::Real; relax::Bool=false, custom_UJ=nothing)\n\nConvects the pfield by timestep dt using a forward Euler step.\n\nArguments\n\npfield::ParticleField The particle field to integrate.\ndt::Real The time step.\nrelax::Bool Whether to apply relaxation (default: false).\ncustom_UJ Optional custom function for updating U and J.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWVPM.rungekutta3","page":"Reference","title":"FLOWVPM.rungekutta3","text":"Steps the field forward in time by dt in a third-order low-storage Runge-Kutta integration scheme. See Notebook entry 20180105.\n\n\n\n\n\nrungekutta3(pfield::ParticleField, dt::Real; relax::Bool=false, custom_UJ=nothing)\n\nSteps the field forward in time by dt in a third-order low-storage Runge-Kutta integration scheme using the VPM reformulation. See Notebook entry 20180105 (RK integration) and notebook 20210104 (reformulation).\n\nArguments\n\npfield::ParticleField The particle field to integrate.\ndt::R3 The time step.\nrelax::Bool Whether to apply relaxation (default: false).\ncustom_UJ Optional custom function for updating U and J.\n\n\n\n\n\n","category":"function"},{"location":"reference/#UJ","page":"Reference","title":"UJ","text":"","category":"section"},{"location":"reference/#FLOWVPM.UJ_fmm","page":"Reference","title":"FLOWVPM.UJ_fmm","text":"UJ_fmm(pfield)\n\nCalculates the velocity and Jacobian that the field exerts on itself through a fast-multipole approximation, saving U and J on the particles.\n\nNOTE: This method accumulates the calculation on the properties U and J of every particle without previously emptying those properties.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWVPM.UJ_direct-Tuple{ParticleField}","page":"Reference","title":"FLOWVPM.UJ_direct","text":"UJ_direct(pfield)\n\nCalculates the velocity and Jacobian that the field exerts on itself by direct particle-to-particle interaction, saving U and J on the particles.\n\nNOTE: This method accumulates the calculation on the properties U and J of every particle without previously emptying those properties.\n\n\n\n\n\n","category":"method"},{"location":"#FLOWVPM.jl","page":"Introduction","title":"FLOWVPM.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FLOWVPM implements the reformulated vortex particle method (rVPM) developed in E. J. Alvarez' doctoral dissertation Reformulated Vortex Particle Method and Meshless Large Eddy Simulation of Multirotor Aircraft, 2022 [PDF][VIDEO]. The rVPM is a meshless CFD method solving the LES-filtered incompressible Navier-Stokes equations in their vorticity form. It uses a Lagrangian scheme, which not only avoids the hurdles of mesh generation, but it also conserves vortical structures over long distances with minimal numerical dissipation while being orders of magnitude faster than conventional mesh-based CFD.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The rVPM uses particles to discretize the Navier-Stokes equations, with the particles representing radial basis functions that construct a continuous vorticity/velocity field. The basis functions become the LES filter, providing a variable filter width and spatial adaption as the particles are convected and stretched by the velocity field. The local evolution of the filter width provides an extra degree of freedom to re-inforce conservations laws, which makes the reformulated VPM numerically stable.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This meshless CFD has several advantages over conventional mesh-based CFD. In the absence of a mesh, the rVPM (1) does not suffer from the conventional CFL condition, (2) does not suffer from the numerical dissipation introduced by a mesh, and (3) derivatives are calculated analytically rather than approximated through a stencil. Furthermore, rVPM is highly efficient since it uses computational elements only where there is vorticity rather than meshing the entire space, making it 100x faster than conventional mesh-based LES.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FLOWVPM is implemented in Julia, which is a modern, high-level, dynamic programming language for high-performance computing. Paraview is recommended for visualization of simulations.","category":"page"},{"location":"#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Fast-multipole acceleration through FastMultipole.jl\nThreaded CPU parallelization through OpenMP\nMeshless\nSecond-order spatial accuracy and third-order RK time integration\nNumerically stable by reshaping particles subject to vortex stretching\nSubfilter-scale (SFS) model of turbulence associated to vortex stretching\nSFS model coefficient computed dynamically or prescribed\nViscous diffusion through core spreading","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FLOWVPM is a stand-alone simulation framework, but it has also been integrated and used in the following codes: FLOWUnsteady and   VortexLattice","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This is an open-source project.   Improvements and further development by the community are accepted and encouraged.","category":"page"},{"location":"#Theory-and-Validation","page":"Introduction","title":"Theory and Validation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"E. J. Alvarez, 2022, Reformulated Vortex Particle Method and Meshless Large Eddy Simulation of Multirotor Aircraft. Doctoral Dissertation, Brigham Young University. [PDF][VIDEO]\nE. J. Alvarez & A. Ning, 2022, Reviving the Vortex Particle Method: A Stable Formulation for Meshless Large Eddy Simulation. In review. [PDF]\nE. J. Alvarez, J. Mehr, & A. Ning, 2022, FLOWUnsteady: An Interactional Aerodynamics Solver for Multirotor Aircraft and Wind Energy. AIAA AVIATION 2022 Forum. [PDF]","category":"page"},{"location":"#Sponsors","page":"Introduction","title":"Sponsors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Sponsors)","category":"page"},{"location":"#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Turbulent Jet: examples/roundjet/ [VIDEO1] [VIDEO2]   (Image: Turbulent Jet)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Vortex Ring Leapfrog: examples/vortexrings/   (Image: Vortex Ring Leapfrog)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Isolated Vortex Ring: examples/vortexrings/   (Image: Isolated Vortex Ring)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Rotor in Hover: FLOWUnsteady [VIDEO]   (Image: Rotor in Hover)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Ring with Toroidal Vorticity: [LINK] [VIDEO]   (Image: Ring with Toroidal Vorticity)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"eVTOL Aircraft: FLOWUnsteady  [VIDEO]   (Image: eVTOL Aircraft)","category":"page"},{"location":"#About","page":"Introduction","title":"About","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Main Developer    : Eduardo J Alvarez\nEmail             : Edo.AlvarezR@gmail.com\nWebsite           : edoalvarez.com\nCreated           : 2019\nLicense           : MIT","category":"page"}]
}
